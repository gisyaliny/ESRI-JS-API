{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frontend Development Notes","text":"<p>Welcome to my Frontend Development documentation! This site contains my notes, learnings, and best practices for frontend development.</p>"},{"location":"#topics-covered","title":"Topics Covered","text":""},{"location":"#javascript","title":"JavaScript","text":"<ul> <li>Core JavaScript concepts and fundamentals</li> <li>ES6+ features and modern JavaScript</li> <li>DOM manipulation and browser APIs</li> </ul>"},{"location":"#frameworks","title":"Frameworks","text":"<ul> <li>React fundamentals and advanced concepts</li> <li>Vue.js development and best practices</li> </ul>"},{"location":"#css","title":"CSS","text":"<ul> <li>CSS basics and advanced techniques</li> <li>Flexbox layout system</li> <li>CSS Grid layout system</li> </ul>"},{"location":"#development-tools","title":"Development Tools","text":"<ul> <li>Webpack configuration and usage</li> <li>Babel setup and configuration</li> <li>Git workflow and best practices</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Choose a topic from the navigation menu to begin learning. Each section contains detailed explanations, code examples, and best practices.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you find any errors or would like to contribute to these notes, please visit the GitHub repository. </p>"},{"location":"ES6/01-ES6_Core_Syntax/","title":"Core Syntax","text":""},{"location":"ES6/01-ES6_Core_Syntax/#es6-core-syntax-a-comprehensive-tutorial","title":"ES6+ Core Syntax: A Comprehensive Tutorial\u00b6","text":""},{"location":"ES6/01-ES6_Core_Syntax/#introduction","title":"Introduction\u00b6","text":"<p>Welcome to this comprehensive tutorial on ES6+ (ECMAScript 2015 and newer) syntax. JavaScript has evolved significantly with the introduction of ES6, bringing powerful features that make code more readable, maintainable, and expressive. This tutorial is designed for beginners who want to master modern JavaScript.</p> <p>This tutorial covers one week of learning, with each day focusing on different aspects of ES6+. By the end of this tutorial, you'll have a solid understanding of ES6 fundamentals and be able to apply them in your projects.</p>"},{"location":"ES6/01-ES6_Core_Syntax/#day-1-variable-declaration-and-scope","title":"Day 1: Variable Declaration and Scope\u00b6","text":""},{"location":"ES6/01-ES6_Core_Syntax/#understanding-var-let-and-const","title":"Understanding <code>var</code>, <code>let</code>, and <code>const</code>\u00b6","text":"<p>Prior to ES6, we only had <code>var</code> for declaring variables. ES6 introduced <code>let</code> and <code>const</code>, which provide better scoping rules and help avoid common pitfalls of var.</p>"},{"location":"ES6/01-ES6_Core_Syntax/#var-declaration","title":"<code>var</code> Declaration\u00b6","text":"<ul> <li><p><code>var</code> has <code>function scope</code>, which means it's only available within the function it's declared in:</p> <pre>function exampleFunction() {\nvar x = 10;\nconsole.log(x); // 10\n}\n\nexampleFunction();\nconsole.log(x); // ReferenceError: x is not defined\n</pre> </li> <li><p>However, <code>var</code> doesn't have <code>block scope</code>, which can lead to unexpected behavior:</p> <pre>if (true) {\nvar y = 20;\n}\nconsole.log(y); // 20 - accessible outside the block!\n</pre> </li> <li><p>Another issue with <code>var</code> is hoisting, where declarations (but not initializations) are moved to the top of their scope:</p> <pre>console.log(hoistedVar); // undefined (not an error)\nvar hoistedVar = 30;\n</pre> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#let-declaration","title":"<code>let</code> Declaration\u00b6","text":"<ul> <li><p>Declaration &amp; Usage</p> <pre>// Single declaration\nlet score = 42;\n\n// Multiple declarations\nlet x = 1, y = 2, z = 3;\n</pre> </li> <li><p>Block scope: Variables declared with <code>let</code> only exist inside <code>{ \u2026 }</code></p> <pre>{\nlet color = 'blue';\nconsole.log(color); // 'blue'\n}\nconsole.log(color);   // ReferenceError: color is not defined\n</pre> </li> <li><p>No re-declaration: You can\u2019t declare the same name twice in the same scope</p> <pre>let name = 'Alice';\nlet name = 'Bob';     // SyntaxError\n</pre> </li> <li><p>No implicit hoisting: Unlike <code>var</code>, <code>let</code> variables are not initialized until their declaration is reached (Temporal Dead Zone):</p> <pre>console.log(age);     // ReferenceError\nlet age = 30;\n</pre> </li> <li><p>Respects scope chain: Even though <code>let</code> is block-scoped, functions declared inside can still access outer <code>let</code> variables</p> <pre>if (true) {\nlet greeting = 'Hi';\nfunction sayHi() {\n    console.log(greeting);\n}\nsayHi();            // 'Hi'\n}\n</pre> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#common-pitfall-loop-closures","title":"Common Pitfall: Loop Closures\u00b6","text":"<ul> <li><p>Using <code>var</code> in loops can cause bugs when creating callbacks:</p> <pre>&lt;ul id=\"items\"&gt;\n&lt;li&gt;Item 0&lt;/li&gt;\n&lt;li&gt;Item 1&lt;/li&gt;\n&lt;li&gt;Item 2&lt;/li&gt;\n&lt;/ul&gt;\n&lt;script&gt;\nvar list = document.querySelectorAll('#items li');\nfor (var i = 0; i &lt; list.length; i++) {\n    list[i].addEventListener('click', function() {\n    console.log('You clicked item', i);\n    });\n}\n// Clicking *any* item logs \"You clicked item 3\"\n&lt;/script&gt;\n</pre> </li> <li><p>Fix with <code>let</code> (each iteration gets its own <code>i</code>):</p> <pre>const list = document.querySelectorAll('#items li');\nfor (let i = 0; i &lt; list.length; i++) {\nlist[i].addEventListener('click', () =&gt; {\n    console.log('You clicked item', i);\n});\n}\n// Now clicking item 0 logs 0, etc.\n</pre> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#const-block-scoped-constants","title":"<code>const</code>: Block-Scoped Constants\u00b6","text":"<ul> <li><p>Declaration &amp; Usage</p> <pre>const PI = 3.14159;\nconst maxUsers = 100;\n</pre> </li> <li><p>Must initialize at declaration:</p> </li> <li><p>Cannot reassign</p> <pre>const foo;           // SyntaxError: missing initializer\nconst greeting = 'Hello';\ngreeting = 'Hi';     // TypeError: assignment to constant variable\n</pre> </li> <li><p>Block scope (just like <code>let</code>):</p> <pre>{\nconst secret = 'squirrel';\nconsole.log(secret); // 'squirrel'\n}\nconsole.log(secret);   // ReferenceError\n</pre> </li> <li><p>Mutable contents for objects/arrays</p> <ul> <li><p>The binding [address] is constant, but object/array contents can change:</p> <pre>const COLORS = ['red', 'green', 'blue'];\nCOLORS.push('purple');      // OK\nconsole.log(COLORS);\n// ['red','green','blue','purple']\n\nconst user = { name: 'Alice' };\nuser.name = 'Bob';          // OK\nconsole.log(user.name);     // 'Bob'\n</pre> </li> </ul> </li> <li><p>Tip: Use <code>const</code> by default; switch to <code>let</code> only when you know the variable must change.</p> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#practical-example","title":"Practical Example\u00b6","text":"<pre>function calculateTotal(items) {\nconst TAX_RATE = 0.08; // constant that won't change\nlet total = 0; // will be reassigned in the loop\n\nfor (const item of items) { // block scoped, won't be reassigned in loop\n    let itemTotal = item.price; // block scoped\n    \n    if (item.discounted) {\n    const DISCOUNT = 0.1; // block scoped constant\n    itemTotal = itemTotal * (1 - DISCOUNT);\n    }\n    \n    total += itemTotal;\n}\n\nreturn total * (1 + TAX_RATE);\n}\n\nconst shoppingCart = [\n{ name: \"Laptop\", price: 1000, discounted: true },\n{ name: \"Mouse\", price: 50, discounted: false },\n{ name: \"Keyboard\", price: 100, discounted: true }\n];\n\nconsole.log(calculateTotal(shoppingCart)); // 1045.5\n</pre>"},{"location":"ES6/01-ES6_Core_Syntax/#day-2-destructuring-assignment-template-strings","title":"Day 2: Destructuring Assignment &amp; Template Strings\u00b6","text":""},{"location":"ES6/01-ES6_Core_Syntax/#destructuring-assignment","title":"Destructuring Assignment\u00b6","text":"<p>Destructuring allows extracting values from <code>arrays</code> or properties from <code>objects</code> in a concise way.</p>"},{"location":"ES6/01-ES6_Core_Syntax/#array-destructuring","title":"Array Destructuring\u00b6","text":"<pre>// Imagine a list of band members:\nconst beatles = ['John', 'Paul', 'George', 'Ringo'];\n\n// Destructure into variables:\nconst [leadSinger, bassist, guitarist, drummer] = beatles;\nconsole.log(leadSinger);  // 'John'\nconsole.log(drummer);      // 'Ringo'\n</pre> <ul> <li><p>You can skip elements or collect the rest:</p> <pre>const [first, , third] = beatles;\nconsole.log(first, third);      // 'John' 'George'\n\nconst [a, ...rest] = beatles;\nconsole.log(rest);              // ['Paul','George','Ringo']\n</pre> </li> <li><p>Practical Example</p> <pre>// Basic array destructuring\nconst numbers = [1, 2, 3, 4, 5];\nconst [first, second, ...rest] = numbers;\n\nconsole.log(first);  // 1\nconsole.log(second); // 2\nconsole.log(rest);   // [3, 4, 5]\n\n// Skipping elements\nconst colors = [\"red\", \"green\", \"blue\"];\nconst [primaryColor, , tertiaryColor] = colors;\nconsole.log(primaryColor);  // \"red\"\nconsole.log(tertiaryColor); // \"blue\"\n\n// Default values\nconst incomplete = [10];\nconst [value1, value2 = 20] = incomplete;\nconsole.log(value1); // 10\nconsole.log(value2); // 20 (default value)\n\n// Swapping variables\nlet a = 5;\nlet b = 10;\n[a, b] = [b, a];\nconsole.log(a); // 10\nconsole.log(b); // 5\n</pre> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#object-destructuring","title":"Object Destructuring\u00b6","text":"<pre>// A user profile object:\nconst userProfile = {\n  username: 'coder123',\n  email: 'code@example.com',\n  points: 250,\n  sayHello() { console.log(`Hello, ${this.username}!`); }\n};\n\n// Pull properties into variables:\nconst { username, points, sayHello } = userProfile;\n\nconsole.log(username);  // 'coder123'\nconsole.log(points);    // 250\nsayHello();             // 'Hello, coder123!'\n</pre> <ul> <li><p>You can also rename variables and set defaults:</p> <pre>const {\nemail: userEmail,       // rename\nlevel = 'guest'         // default if missing\n} = userProfile;\nconsole.log(userEmail, level);\n</pre> </li> <li><p>Practical Example</p> <pre>// Basic object destructuring\nconst person = {\n  name: \"Alice\",\n  age: 30,\n  location: \"New York\"\n};\n\nconst { name, age } = person;\nconsole.log(name); // \"Alice\"\nconsole.log(age);  // 30\n\n// Assigning to different variable names\nconst { name: personName, age: years } = person;\nconsole.log(personName); // \"Alice\"\nconsole.log(years);      // 30\n\n// Default values\nconst incomplete = { status: \"pending\" };\nconst { status, message = \"No message provided\" } = incomplete;\nconsole.log(status);  // \"pending\"\nconsole.log(message); // \"No message provided\" (default value)\n\n// Nested destructuring\nconst user = {\n  id: 123,\n  profile: {\n    firstName: \"John\",\n    lastName: \"Doe\",\n    socials: {\n      twitter: \"@johndoe\",\n      facebook: \"john.doe\"\n    }\n  }\n};\n\nconst { profile: { firstName, lastName, socials: { twitter } } } = user;\nconsole.log(firstName); // \"John\"\nconsole.log(lastName);  // \"Doe\"\nconsole.log(twitter);   // \"@johndoe\"\n</pre> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#function-parameter-destructuring","title":"Function Parameter Destructuring\u00b6","text":"<pre>// Destructuring in function parameters\nfunction displayUser({ name, age, role = \"User\" }) {\n  console.log(`${name}, ${age}, ${role}`);\n}\n\ndisplayUser({ name: \"Alice\", age: 30 }); // \"Alice, 30, User\"\ndisplayUser({ name: \"Bob\", age: 25, role: \"Admin\" }); // \"Bob, 25, Admin\"\n</pre> <ul> <li><p>Simple Defaults</p> <ul> <li>Tip: Place parameters with defaults after those without, so callers rarely need to pass <code>undefined</code>.</li> </ul> <pre>function add(a, b = 5) {\n  return a + b;\n}\nconsole.log(add(3));    // \u2192 8\nconsole.log(add(3, 2)); // \u2192 5\n</pre> </li> <li><p>Destructured Defaults</p> <ul> <li>Why <code>= {}</code> at end?</li> <li>It allows calling <code>connect()</code> with no arguments, since you\u2019re destructuring a default empty object.</li> </ul> <pre>// Without defaults:\nfunction connect(opts) {\n  const host     = opts.host;\n  const port     = opts.port;\n  const username = opts.username;\n  // \u2026\n}\n\n// With destructuring + defaults:\nfunction connect({\n  host     = 'localhost',\n  port     = 5432,\n  username = 'admin',\n  password = ''\n} = {}) {\n  console.log(`Connecting to ${host}:${port} as ${username}`);\n}\n\nconnect({});  \n// \u2192 Connecting to localhost:5432 as admin\n\nconnect({ host: 'db.example.com', username: 'alice' });\n// \u2192 Connecting to db.example.com:5432 as alice\n</pre> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#practical-exercises","title":"Practical Exercises\u00b6","text":"<ul> <li><p>Write <code>formatDate({ day, month, year = 2025 })</code> that returns <code>\"MM/DD/YYYY\"</code>. Test with missing properties.</p> <pre>function formatDate({ day, month, year = 2025 } = {}) {\n// Pad single digits with leading zero\nconst dd = String(day).padStart(2, '0');\nconst mm = String(month).padStart(2, '0');\nreturn `${mm}/${dd}/${year}`;\n}\n\n// Tests\nconsole.log(formatDate({ day: 1, month: 2 })); \n// \u2192 \"02/01/2025\"   (uses default year)\n\nconsole.log(formatDate({ day: 15, month: 7, year: 2021 }));\n// \u2192 \"07/15/2021\"\n\nconsole.log(formatDate()); \n// \u2192 \"undefined/undefined/2025\" (since day/month are undefined)\n</pre> </li> <li><p>Note: If you want safe defaults for <code>day</code> and <code>month</code>, you could also give them defaults in the signature:</p> <ul> <li>That way <code>formatDate()</code> yields <code>\"01/01/2025\"</code></li> </ul> <pre>function formatDate({ day = 1, month = 1, year = 2025 } = {}) { \u2026 }\n</pre> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#template-strings","title":"Template Strings\u00b6","text":"<ul> <li>Template strings (<code>template literals</code>) provide an improved way to work with strings, allowing embedded expressions and multi-line strings.</li> <li>Backtick-delimited strings let you do multi-line text and interpolation with <code>${\u2026}</code>.</li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#basic-syntax","title":"Basic Syntax\u00b6","text":"<pre>const name = \"Alice\";\nconst greeting = `Hello, ${name}!`;\nconsole.log(greeting); // \"Hello, Alice!\"\n\n// Expressions in template strings\nconst a = 5;\nconst b = 10;\nconsole.log(`The sum of ${a} and ${b} is ${a + b}`); // \"The sum of 5 and 10 is 15\"\n\n// Multi-line strings\nconst multiLine = `This is a \nmulti-line\nstring in JavaScript!`;\nconsole.log(multiLine);\n// \"This is a \n// multi-line\n// string in JavaScript!\"\n</pre> <ul> <li><p>Multi-line Strings</p> <pre>const address = `221B Baker Street\nLondon, UK\nNW1 6XE`;\n\nconsole.log(address);\n</pre> </li> <li><p>Interpolation</p> <pre>const firstName = 'Ada';\nconst lastName  = 'Lovelace';\nconst greeting  = `Hello, ${firstName} ${lastName}!`;\n\nconsole.log(greeting);\n// \u2192 Hello, Ada Lovelace!\n</pre> </li> <li><p>Building HTML Snippets</p> <pre>function renderUser({ name, age }) {\nreturn `\n    &lt;div class=\"user-card\"&gt;\n    &lt;h2&gt;${name}&lt;/h2&gt;\n    &lt;p&gt;Age: ${age}&lt;/p&gt;\n    &lt;/div&gt;\n`;\n}\n\nconsole.log(renderUser({ name: 'Sam', age: 28 }));\n</pre> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#tagged-templates","title":"Tagged Templates\u00b6","text":"<ul> <li><p>Tagged templates allow you to parse template literals with a function:</p> <pre>function highlight(strings, ...values) {\n  return strings.reduce((result, string, i) =&gt; {\n    return `${result}${string}${values[i] ? `&lt;strong&gt;${values[i]}&lt;/strong&gt;` : ''}`;\n  }, '');\n}\n\nconst name = \"Alice\";\nconst age = 30;\nconst highlightedText = highlight`My name is ${name} and I am ${age} years old.`;\nconsole.log(highlightedText); \n// \"My name is &lt;strong&gt;Alice&lt;/strong&gt; and I am &lt;strong&gt;30&lt;/strong&gt; years old.\"\n</pre> </li> <li><p>How the arguments look</p> </li> <li><p>Given <code>highlightMy name is ${name} and I am ${age} years old.;</code></p> </li> <li><p><code>strings</code> will be</p> <pre>[\n  \"My name is \",\n  \" and I am \",\n  \" years old.\"\n]\n</pre> </li> <li><p><code>values</code> (the rest parameters) will be <code>[\"Alice\", 30]</code></p> </li> <li><p>Under the hood the call is essentially:</p> <pre>highlight(\n  [\"My name is \", \" and I am \", \" years old.\"],\n  \"Alice\",\n  30\n);\n</pre> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#practical-example","title":"Practical Example\u00b6","text":"<ul> <li><p>Create a function called <code>sanitize</code> that:</p> <ul> <li><p>Receives the <code>strings</code> array and <code>...values</code>.</p> </li> <li><p>Escapes HTML-sensitive characters in each value.</p> </li> <li><p>Reconstructs and returns the safe HTML string.</p> </li> <li><p>Here\u2019s a skeleton to get you started</p> </li> </ul> <pre>function sanitize(strings, ...values) {\n  // Helper to escape a single value\n  const escapeHTML = str =&gt; (\n    String(str)\n      .replace(/&amp;/g, '&amp;amp;')\n      .replace(/&lt;/g, '&amp;lt;')\n      .replace(/&gt;/g, '&amp;gt;')\n      .replace(/\"/g, '&amp;quot;')\n      .replace(/'/g, '&amp;#39;')\n  );\n\n  // Build the result\n  return strings.reduce((result, text, i) =&gt; {\n    const val = values[i];\n    return result +\n      text +\n      (i &lt; values.length\n        ? escapeHTML(val)\n        : ''\n      );\n  }, '');\n}\n</pre> </li> <li><p>Test with malicious-looking input</p> <pre>const userName   = 'Alice';\nconst comment    = '&lt;script&gt;alert(\"XSS\")&lt;/script&gt;';\nconst safeOutput = sanitize`\n  &lt;p&gt;User: ${userName}&lt;/p&gt;\n  &lt;p&gt;Comment: ${comment}&lt;/p&gt;\n`;\n\nconsole.log(safeOutput);\n</pre> </li> <li><p>Expected Console Output:</p> <pre>&lt;p&gt;User: Alice&lt;/p&gt;\n&lt;p&gt;Comment: &amp;lt;script&amp;gt;alert(&amp;quot;XSS&amp;quot;)&amp;lt;/script&amp;gt;&lt;/p&gt;\n</pre> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#day-3-enhanced-functions","title":"Day 3: Enhanced Functions\u00b6","text":""},{"location":"ES6/01-ES6_Core_Syntax/#arrow-functions","title":"Arrow Functions\u00b6","text":"<ul> <li>Arrow functions provide a shorter syntax for writing functions and do not bind their own <code>this</code>.</li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#basic-syntax","title":"Basic Syntax\u00b6","text":"<ul> <li><p>Arrow functions (<code>=&gt;</code>) provide a shorter syntax for writing functions and they capture the this value of their surrounding scope.</p> <pre>// Traditional function\nfunction add(a, b) {\nreturn a + b;\n}\n\n// Arrow function\nconst addArrow = (a, b) =&gt; a + b;\n\nconsole.log(add(5, 3));      // 8\nconsole.log(addArrow(5, 3)); // 8\n</pre> </li> </ul>"},{"location":"ES6/01-ES6_Core_Syntax/#syntax-variations","title":"Syntax Variations\u00b6","text":"<pre>// No parameters\nconst sayHello = () =&gt; \"Hello!\";\n\n// Single parameter (parentheses optional)\nconst double = num =&gt; num * 2;\n// const double = (num) =&gt; num * 2; // Also valid\n\n// Multiple parameters (parentheses required)\nconst multiply = (a, b) =&gt; a * b;\n\n// Multiple statements (curly braces and explicit return required)\nconst calculateTotal = (price, tax) =&gt; {\nconst taxAmount = price * tax;\nreturn price + taxAmount;\n};\n\nconsole.log(sayHello());          // \"Hello!\"\nconsole.log(double(5));           // 10\nconsole.log(multiply(4, 6));      // 24\nconsole.log(calculateTotal(100, 0.08)); // 108\n</pre>"},{"location":"ES6/01-ES6_Core_Syntax/#this-binding","title":"<code>this</code> Binding\u00b6","text":"<ul> <li><p>Arrow functions don't have their own <code>this</code> context. They inherit <code>this</code> from the surrounding code:</p> </li> <li><p>This is perfect for <code>callbacks</code></p> <pre>&lt;button id=\"btn\"&gt;Click me&lt;/button&gt;\n&lt;script&gt;\nconst btn = document.getElementById('btn');\nbtn.addEventListener('click', () =&gt; {\n    // `this` here is the same `this` as outer scope (e.g. window),\n    // so avoid arrow functions if you need the element itself\n    console.log(this); \n});\n&lt;/script&gt;\n</pre> </li> <li><p>for array methods or timers, arrow functions shine:</p> <pre>// Problem with traditional functions\nconst counter = {\ncount: 0,\nincrementLater: function() {\n    setTimeout(function() {\n    this.count++; // 'this' refers to window/global object, not counter\n    console.log(this.count);\n    }, 1000);\n}\n};\ncounter.incrementLater(); // NaN or error\n\n// Solution with arrow function\nconst betterCounter = {\ncount: 0,\nincrementLater: function() {\n    setTimeout(() =&gt; {\n    this.count++; // 'this' refers to betterCounter\n    console.log(this.count);\n    }, 1000);\n}\n};\nbetterCounter.incrementLater(); // 1\n</pre> </li> <li><p>When Not to Use</p> <ol> <li>Object methods needing this</li> </ol> <pre>// 1. Object Method Needing `this`\n// Using an arrow function for a method means `this` is inherited\nconst counter = {\ncount: 0,\n// Arrow function: `this` is not `counter`!\nincrement: () =&gt; {\n    this.count++;\n    console.log(this.count);\n},\n// Correct: use a regular function to bind `this` to `counter`\nincrementCorrect() {\n    this.count++;\n    console.log(this.count);\n}\n};\n\ncounter.increment();         // NaN or error, `this.count` is undefined\ncounter.incrementCorrect();  // 1\n</pre> <ol> <li>Constructor functions (cannot use new with arrows)</li> </ol> <pre>// 2. Constructor Functions (Arrow Cannot Be Used with `new`)\nconst Person = (name) =&gt; {\nthis.name = name;\n};\n// Attempt to use `new` with an arrow will throw:\ntry {\nconst p = new Person('Alice');\n} catch (e) {\nconsole.error(e); // TypeError: Person is not a constructor\n}\n\n// Correct: use a regular function or class\nfunction PersonFunc(name) {\nthis.name = name;\n}\nconst p2 = new PersonFunc('Bob');\nconsole.log(p2.name); // 'Bob'\n</pre> <ol> <li>Event handlers when you rely on this being the DOM element</li> </ol> <pre>// 3. Event Handlers Relying on `this` Being the DOM Element\n// Using an arrow function here, `this` is inherited (e.g., window), not the element\nconst button = document.createElement('button');\nbutton.textContent = 'Click me';\ndocument.body.appendChild(button);\n\nbutton.addEventListener('click', () =&gt; {\nconsole.log(this);            // window (or undefined in strict mode)\nconsole.log(this.textContent); // undefined\n});\n\n// Correct: use a regular function expression\nbutton.addEventListener('click', function() {\nconsole.log(this);            // the &lt;button&gt; element\nconsole.log(this.textContent); // 'Click me'\n});\n</pre> </li> </ul>"},{"location":"javascript/basics/","title":"JavaScript Basics","text":""},{"location":"javascript/basics/#variables-and-data-types","title":"Variables and Data Types","text":"<p>JavaScript has several ways to declare variables:</p> <pre><code>// Using var (function-scoped)\nvar name = \"John\";\n\n// Using let (block-scoped)\nlet age = 25;\n\n// Using const (block-scoped, immutable binding)\nconst PI = 3.14159;\n</code></pre>"},{"location":"javascript/basics/#primitive-data-types","title":"Primitive Data Types","text":"<p>JavaScript has 7 primitive data types:</p> <ol> <li><code>string</code></li> <li><code>number</code></li> <li><code>boolean</code></li> <li><code>null</code></li> <li><code>undefined</code></li> <li><code>symbol</code></li> <li><code>bigint</code></li> </ol> <p>Example: <pre><code>let str = \"Hello\";           // string\nlet num = 42;                // number\nlet bool = true;             // boolean\nlet nothing = null;          // null\nlet undef = undefined;       // undefined\nlet sym = Symbol();          // symbol\nlet bigInt = 9007199254740991n; // bigint\n</code></pre></p>"},{"location":"javascript/basics/#functions","title":"Functions","text":"<p>Functions in JavaScript can be declared in several ways:</p> <pre><code>// Function Declaration\nfunction greet(name) {\n    return `Hello, ${name}!`;\n}\n\n// Function Expression\nconst greet = function(name) {\n    return `Hello, ${name}!`;\n};\n\n// Arrow Function\nconst greet = (name) =&gt; `Hello, ${name}!`;\n</code></pre>"},{"location":"javascript/basics/#control-flow","title":"Control Flow","text":""},{"location":"javascript/basics/#conditional-statements","title":"Conditional Statements","text":"<pre><code>if (condition) {\n    // code\n} else if (anotherCondition) {\n    // code\n} else {\n    // code\n}\n\n// Ternary operator\nconst result = condition ? \"yes\" : \"no\";\n\n// Switch statement\nswitch (value) {\n    case 1:\n        // code\n        break;\n    case 2:\n        // code\n        break;\n    default:\n        // code\n}\n</code></pre>"},{"location":"javascript/basics/#loops","title":"Loops","text":"<pre><code>// For loop\nfor (let i = 0; i &lt; 5; i++) {\n    console.log(i);\n}\n\n// While loop\nlet i = 0;\nwhile (i &lt; 5) {\n    console.log(i);\n    i++;\n}\n\n// For...of loop (for iterables)\nfor (const item of array) {\n    console.log(item);\n}\n\n// For...in loop (for object properties)\nfor (const key in object) {\n    console.log(key, object[key]);\n}\n</code></pre>"},{"location":"javascript/basics/#error-handling","title":"Error Handling","text":"<pre><code>try {\n    // Code that might throw an error\n    throw new Error(\"Something went wrong\");\n} catch (error) {\n    console.error(error.message);\n} finally {\n    // Code that runs regardless of error\n}\n</code></pre>"},{"location":"javascript/basics/#best-practices","title":"Best Practices","text":"<ol> <li>Always use <code>const</code> or <code>let</code> instead of <code>var</code></li> <li>Use meaningful variable and function names</li> <li>Keep functions small and focused</li> <li>Use proper error handling</li> <li>Comment your code when necessary</li> <li>Use strict mode with <code>'use strict';</code></li> <li>Follow consistent code formatting </li> </ol>"}]}